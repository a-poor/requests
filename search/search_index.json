{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"requests created by Austin Poor Welcome to the documentation for the Go package [github.com/a-poor/request]. requests is quick and easy HTTP request library written in Go. This library is inspired by the Python Requests library. I wrote it for myself in order to make the HTTP client process a little more ergonomic when writing Go code. Table of Contents Installation Quick Start Dependencies Contributing License Installation Installation is quick and easy! go get github.com/a-poor/requests Quick Start Here's a quick example of requests in action. package main import ( \"fmt\" \"github.com/a-poor/requests\" ) func main () { // Send the request res , err := requests . SendGetRequest ( \"https://google.com\" ) // If there was an error, print and return if err != nil { fmt . Printf ( \"Error: %e\\n\" , err ) return } // Print the response's status code fmt . Printf ( \"Status Code: %d\\n\" , res . StatusCode ) } Dependencies Only the standard library! Contributing Pull requests are super welcome! For major changes, please open an issue first to discuss what you would like to change. And please make sure to update tests as appropriate. Or ... feel free to just open an issue with some thoughts or suggestions or even just to say Hi and tell me if this library has been helpful! License MIT","title":"Home"},{"location":"#requests","text":"created by Austin Poor Welcome to the documentation for the Go package [github.com/a-poor/request]. requests is quick and easy HTTP request library written in Go. This library is inspired by the Python Requests library. I wrote it for myself in order to make the HTTP client process a little more ergonomic when writing Go code.","title":"requests"},{"location":"#table-of-contents","text":"Installation Quick Start Dependencies Contributing License","title":"Table of Contents"},{"location":"#installation","text":"Installation is quick and easy! go get github.com/a-poor/requests","title":"Installation"},{"location":"#quick-start","text":"Here's a quick example of requests in action. package main import ( \"fmt\" \"github.com/a-poor/requests\" ) func main () { // Send the request res , err := requests . SendGetRequest ( \"https://google.com\" ) // If there was an error, print and return if err != nil { fmt . Printf ( \"Error: %e\\n\" , err ) return } // Print the response's status code fmt . Printf ( \"Status Code: %d\\n\" , res . StatusCode ) }","title":"Quick Start"},{"location":"#dependencies","text":"Only the standard library!","title":"Dependencies"},{"location":"#contributing","text":"Pull requests are super welcome! For major changes, please open an issue first to discuss what you would like to change. And please make sure to update tests as appropriate. Or ... feel free to just open an issue with some thoughts or suggestions or even just to say Hi and tell me if this library has been helpful!","title":"Contributing"},{"location":"#license","text":"MIT","title":"License"},{"location":"extras/","text":"Extras Oops! It looks like I haven't gotten here yet...","title":"Extras"},{"location":"extras/#extras","text":"Oops! It looks like I haven't gotten here yet...","title":"Extras"},{"location":"quick-start/","text":"Quick Start Want to get up and running quickly? Here are a few examples... Basic GET Requests The requests.SendGetRequest function makes a GET request to a URL. res , err := requests . SendGetRequest ( \"https://example.com/greet\" ) if err != nil { log . Panic ( err ) } fmt . Printf ( \"Status Code: %d\\n\" , res . StatusCode ) // Status Code: 200 fmt . Printf ( \"Body: %q\\n\" , string ( res . Body )) // Body: \"Hello, World!\" Basic POST Requests The requests.SendPostRequest function makes a POST request to a URL, with the specified body and contentType . url := \"https://example.com/greet\" contentType := \"application/json\" body := [] byte ( `{\"name\": \"gopher\"}` ) res , err := requests . SendPostRequest ( url , contentType , body ) if err != nil { log . Panic ( err ) } fmt . Printf ( \"Status Code: %d\\n\" , res . StatusCode ) // Status Code: 200 fmt . Printf ( \"Body: %q\\n\" , string ( res . Body )) // Body: \"Hello, Gopher!\" But that's just the start! Keep reading to learn about more advanced ways to build HTTP requests that meet your needs.","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"Want to get up and running quickly? Here are a few examples...","title":"Quick Start"},{"location":"quick-start/#basic-get-requests","text":"The requests.SendGetRequest function makes a GET request to a URL. res , err := requests . SendGetRequest ( \"https://example.com/greet\" ) if err != nil { log . Panic ( err ) } fmt . Printf ( \"Status Code: %d\\n\" , res . StatusCode ) // Status Code: 200 fmt . Printf ( \"Body: %q\\n\" , string ( res . Body )) // Body: \"Hello, World!\"","title":"Basic GET Requests"},{"location":"quick-start/#basic-post-requests","text":"The requests.SendPostRequest function makes a POST request to a URL, with the specified body and contentType . url := \"https://example.com/greet\" contentType := \"application/json\" body := [] byte ( `{\"name\": \"gopher\"}` ) res , err := requests . SendPostRequest ( url , contentType , body ) if err != nil { log . Panic ( err ) } fmt . Printf ( \"Status Code: %d\\n\" , res . StatusCode ) // Status Code: 200 fmt . Printf ( \"Body: %q\\n\" , string ( res . Body )) // Body: \"Hello, Gopher!\" But that's just the start! Keep reading to learn about more advanced ways to build HTTP requests that meet your needs.","title":"Basic POST Requests"},{"location":"understanding-responses/","text":"Understanding Responses Sending an HTTP request with a requests.Request object will return a requests.Response . Anatomy of a Response Here's what the requests.Response struct looks like: type Response struct { Ok bool // Was the request successful? (Status codes: 100-399) StatusCode int // HTTP response status code Headers map [ string ] string // HTTP Response headers Body [] byte // HTTP Response body } StatusCode stores the HTTP Response status-code, and helps the user determine if their request was successful. You can read more about HTTP status codes here . The value of Ok is based on the status code (anything under 400 ) and gives the user a more-simplified idea of the success of the request. Headers stores the HTTP response headers. Like the Request struct, Response has a GetHeader function to perform a case-insensitive check for a header. Finally, Body stores the HTTP response body as a slice of bytes.","title":"Understanding Responses"},{"location":"understanding-responses/#understanding-responses","text":"Sending an HTTP request with a requests.Request object will return a requests.Response .","title":"Understanding Responses"},{"location":"understanding-responses/#anatomy-of-a-response","text":"Here's what the requests.Response struct looks like: type Response struct { Ok bool // Was the request successful? (Status codes: 100-399) StatusCode int // HTTP response status code Headers map [ string ] string // HTTP Response headers Body [] byte // HTTP Response body } StatusCode stores the HTTP Response status-code, and helps the user determine if their request was successful. You can read more about HTTP status codes here . The value of Ok is based on the status code (anything under 400 ) and gives the user a more-simplified idea of the success of the request. Headers stores the HTTP response headers. Like the Request struct, Response has a GetHeader function to perform a case-insensitive check for a header. Finally, Body stores the HTTP response body as a slice of bytes.","title":"Anatomy of a Response"},{"location":"examples/","text":"Examples Oops! It looks like I haven't gotten here yet...","title":"Examples"},{"location":"examples/#examples","text":"Oops! It looks like I haven't gotten here yet...","title":"Examples"},{"location":"requests/","text":"Building Requests Most of the time you're making requests, you'll likely want to configure the request parameters. Anatomy of a Request HTTP requests made with the requests library are all based around the Request struct. Here's what the requests.Request struct looks like: type Request struct { URL string // URL to send the request to Method HTTPMethod // HTTP method to use Headers map [ string ] string // Headers to send with the request Query map [ string ] string // Query parameters to send with the request Body [] byte // Body to send with the request Timeout time . Duration // Timeout for the request } The request fields can be set directly or using helper functions. Request Parameters Most of the parameters are probably pretty self explanitory but here's a breakdown of what each parameter means: Name Function Example URL The HTTP endpoint being accessed http://google.com Method HTTP Method being used GET , POST , PUT Headers HTTP Headers Content-Type , Authorization Query Query parameters added to the end of the URL <url>?name=Gopher Body HTTP Request body ie JSON POST data Timeout Time before the request will timeout (Note: Timeout: 0 will never timeout) 0 , 5 * time.Second For more information, consult the docs . Request Methods The HTTP methods are represented as enums/constants of type requests.HTTPMethod like so: const ( GET HTTPMethod = iota // An HTTP GET method POST // An HTTP POST method PUT // An HTTP PUT method DELETE // An HTTP DELETE method OPTIONS // An HTTP OPTIONS method HEAD // An HTTP HEAD method CONNECT // An HTTP CONNECT method TRACE // An HTTP TRACE method PATCH // An HTTP PATCH method ) They have one method, String which converts them to their text representation ( ex requests.GET.String == \"GET\" ). Sending Requests Once you have a request that you're ready to send, you can call the Send method. Send has the following signature: func ( req * Request ) Send () ( * Response , error ) And here's an example of it in action // Create your Request req := requests . Request { URL : \"https://example.com\" , Method : requests . GET } // Send your request res , err := req . Send () if err != nil { log . Panic ( err ) } // Do something with the response... log . Println ( string ( res . Body )) // Output: Hello, world! Alternatively, if you're sure no error will be raised, you can use the req.MustSend method which has the following signature: func ( req * Request ) MustSend () * Response WARNING : This is probably a bad idea, most of the time. Under the hood, this will call req.Send and, if an error is encountered, it will cause a panic.","title":"Building Requests"},{"location":"requests/#building-requests","text":"Most of the time you're making requests, you'll likely want to configure the request parameters.","title":"Building Requests"},{"location":"requests/#anatomy-of-a-request","text":"HTTP requests made with the requests library are all based around the Request struct. Here's what the requests.Request struct looks like: type Request struct { URL string // URL to send the request to Method HTTPMethod // HTTP method to use Headers map [ string ] string // Headers to send with the request Query map [ string ] string // Query parameters to send with the request Body [] byte // Body to send with the request Timeout time . Duration // Timeout for the request } The request fields can be set directly or using helper functions.","title":"Anatomy of a Request"},{"location":"requests/#request-parameters","text":"Most of the parameters are probably pretty self explanitory but here's a breakdown of what each parameter means: Name Function Example URL The HTTP endpoint being accessed http://google.com Method HTTP Method being used GET , POST , PUT Headers HTTP Headers Content-Type , Authorization Query Query parameters added to the end of the URL <url>?name=Gopher Body HTTP Request body ie JSON POST data Timeout Time before the request will timeout (Note: Timeout: 0 will never timeout) 0 , 5 * time.Second For more information, consult the docs .","title":"Request Parameters"},{"location":"requests/#request-methods","text":"The HTTP methods are represented as enums/constants of type requests.HTTPMethod like so: const ( GET HTTPMethod = iota // An HTTP GET method POST // An HTTP POST method PUT // An HTTP PUT method DELETE // An HTTP DELETE method OPTIONS // An HTTP OPTIONS method HEAD // An HTTP HEAD method CONNECT // An HTTP CONNECT method TRACE // An HTTP TRACE method PATCH // An HTTP PATCH method ) They have one method, String which converts them to their text representation ( ex requests.GET.String == \"GET\" ).","title":"Request Methods"},{"location":"requests/#sending-requests","text":"Once you have a request that you're ready to send, you can call the Send method. Send has the following signature: func ( req * Request ) Send () ( * Response , error ) And here's an example of it in action // Create your Request req := requests . Request { URL : \"https://example.com\" , Method : requests . GET } // Send your request res , err := req . Send () if err != nil { log . Panic ( err ) } // Do something with the response... log . Println ( string ( res . Body )) // Output: Hello, world! Alternatively, if you're sure no error will be raised, you can use the req.MustSend method which has the following signature: func ( req * Request ) MustSend () * Response WARNING : This is probably a bad idea, most of the time. Under the hood, this will call req.Send and, if an error is encountered, it will cause a panic.","title":"Sending Requests"},{"location":"requests/header-and-query/","text":"Headers and Query Parameters There are get , set , and del functions to help with request Headers and Query Parameters . Note : requests doesn't support multiple values for headers or query parameters. Sorry :\\ HTTP Headers Headers are stored as a map[string]string . When forming a request, headers can be set directly, like so: req := Requests { Headers : map [ string ] string { \"Content-Type\" : \"application/json\" , \"Accept\" : \"application/json\" , \"Authorization\" : \"Bearer abc123...\" , } } Headers also have the following helper functions: func ( req * Request ) GetHeader ( name string ) ( string , bool ) func ( req * Request ) SetHeader ( name , value string ) func ( req * Request ) DelHeader ( name string ) These functions also come in handy since HTTP headers are case-insensitive . Each of the functions will convert the name parameter to lowercase before setting / getting / deleting. Here's an example of headers in action: // Create a request req := requests . Request {} // Set a header req . SetHeader ( \"CoNtEnT-tYpE\" , \"application/json\" ) // Get the header (with different case) v , ok := req . GetHeader ( \"Content-Type\" ) // Confirm the header was found fmt . Println ( ok ) // Output: true fmt . Println ( v ) // Output: application/json Query Parameters Similar to Headers, there are the following methods for setting / getting / deleting Query parameters. Query strings are encoded as part of a URL. URLs have the following structure: scheme://host:port/path?query#fragment The following example... https://example.com/about?name=gopher&language=en ...breaks down into the following components... Component Example Scheme HTTPS Host example.com Port none Path /about Query map[string]string{\"name\": \"gopher\", \"lang\": \"en\"} Fragment none Note : Unlike HTTP Headers, Query parameters are case sensitive. The requests.Request Query parameters can also be set directly. For example: req := Requests { Query : map [ string ] string { \"name\" : \"gopher\" , \"lang\" : \"en\" , } } Or via the following helper functions: func ( req * Request ) GetQuery ( name string ) ( string , bool ) func ( req * Request ) SetQuery ( name , value string ) func ( req * Request ) DelQuery ( name string ) Note : When a requests.Request is being sent, the Query parameters are encoded using Go's net/url package. This provides safety for the user when passing in the URL rather than naively concatenating the query-string to the URL ( ex fmt.Sprintf(\"%s?%s\", req.URL, encodedQuery) ).","title":"Headers and Query Parameters"},{"location":"requests/header-and-query/#headers-and-query-parameters","text":"There are get , set , and del functions to help with request Headers and Query Parameters . Note : requests doesn't support multiple values for headers or query parameters. Sorry :\\","title":"Headers and Query Parameters"},{"location":"requests/header-and-query/#http-headers","text":"Headers are stored as a map[string]string . When forming a request, headers can be set directly, like so: req := Requests { Headers : map [ string ] string { \"Content-Type\" : \"application/json\" , \"Accept\" : \"application/json\" , \"Authorization\" : \"Bearer abc123...\" , } } Headers also have the following helper functions: func ( req * Request ) GetHeader ( name string ) ( string , bool ) func ( req * Request ) SetHeader ( name , value string ) func ( req * Request ) DelHeader ( name string ) These functions also come in handy since HTTP headers are case-insensitive . Each of the functions will convert the name parameter to lowercase before setting / getting / deleting. Here's an example of headers in action: // Create a request req := requests . Request {} // Set a header req . SetHeader ( \"CoNtEnT-tYpE\" , \"application/json\" ) // Get the header (with different case) v , ok := req . GetHeader ( \"Content-Type\" ) // Confirm the header was found fmt . Println ( ok ) // Output: true fmt . Println ( v ) // Output: application/json","title":"HTTP Headers"},{"location":"requests/header-and-query/#query-parameters","text":"Similar to Headers, there are the following methods for setting / getting / deleting Query parameters. Query strings are encoded as part of a URL. URLs have the following structure: scheme://host:port/path?query#fragment The following example... https://example.com/about?name=gopher&language=en ...breaks down into the following components... Component Example Scheme HTTPS Host example.com Port none Path /about Query map[string]string{\"name\": \"gopher\", \"lang\": \"en\"} Fragment none Note : Unlike HTTP Headers, Query parameters are case sensitive. The requests.Request Query parameters can also be set directly. For example: req := Requests { Query : map [ string ] string { \"name\" : \"gopher\" , \"lang\" : \"en\" , } } Or via the following helper functions: func ( req * Request ) GetQuery ( name string ) ( string , bool ) func ( req * Request ) SetQuery ( name , value string ) func ( req * Request ) DelQuery ( name string ) Note : When a requests.Request is being sent, the Query parameters are encoded using Go's net/url package. This provides safety for the user when passing in the URL rather than naively concatenating the query-string to the URL ( ex fmt.Sprintf(\"%s?%s\", req.URL, encodedQuery) ).","title":"Query Parameters"},{"location":"requests/path-params/","text":"URL Path Parameters The requests library also supports working with path parameters . What are Path parameters? REST APIs and web servers often use variable path parameters. For example, you might have an API with the following schema: /api/users/{userId}/reports/{reportId} So in this example, you could access report r456 , which is owned by user u123 , at the following path: /api/users/u123/reports/r456 How can requests help? requests can help you handle path parameters using Go templates . When creating a Request you can include Go template syntax in the URL parameter and call the ParsePathParams method to fill in the data. To continue the above example, say we're accessing multiple user's reports. We might have data in the following form: type UserReport struct { UserID string ReportID string } We can create our Request object like so: baseReq := requests . Request { URL : `/api/users/{{ .UserID }}/reports/{{ .ReportID }}` } fmt . Println ( baseReq . URL ) // Output: /api/users/{{ .UserID }}/reports/{{ .ReportID }} And we can create new request objects from our baseReq using instances of UserReport . data := [] UserReport { { \"u123\" , \"r456\" }, { \"u321\" , \"r654\" }, { \"u111\" , \"r222\" }, } for _ , ur := range data { req , err := baseReq . ParsePathParams ( & ur ) if err != nil { panic ( err ) } fmt . Println ( req . URL ) } You'll get the following output: /api/users/u123/reports/r456 /api/users/u321/reports/r654 Go templates are a really powerful feature of the language and you can read more about them here . Safely Encoding Path Parameters There is a limited set of characters that are considered safe for URLs (See section 2.3 of RFC 3986 ), and they are: ALPHA DIGIT \"-\" / \".\" / \"_\" / \"~\" requests includes a helper function, URLEncode , to allow you to escape unsafe characters when parsing Path parameters. func URLEncode ( data interface {}) string URLEncode is a convenience function that applies fmt.Sprint and then url.PathEscape . In addition to being a package function, URLEscape is also available in the URL Go template. For example, say we have the following URL template: /api/{{ .Message }} and we want to pass in the message \"Hello, World!\". We'll run into a bit of an issue, since the comma, the space, and the exclamation point are all considered unsafe characters. We can update our template as follows: /api/{{ .Message | URLEscape }} and by piping .Message into the URLEscape function, we'll end up with the following: /api/Hello%2C%20World%21 Yay! Back to safety! If you know your parameters are safe, you can skip URLEscape , but it's there if you need it. Handling Errors Keep in mind that the ParsePathParams method returns both a new request and an error. If you're confident this call won't return an error, you can use the MustParsePathParams method, which only returns the new request and panics if an error is encountered.","title":"URL Path Parameters"},{"location":"requests/path-params/#url-path-parameters","text":"The requests library also supports working with path parameters .","title":"URL Path Parameters"},{"location":"requests/path-params/#what-are-path-parameters","text":"REST APIs and web servers often use variable path parameters. For example, you might have an API with the following schema: /api/users/{userId}/reports/{reportId} So in this example, you could access report r456 , which is owned by user u123 , at the following path: /api/users/u123/reports/r456","title":"What are Path parameters?"},{"location":"requests/path-params/#how-can-requests-help","text":"requests can help you handle path parameters using Go templates . When creating a Request you can include Go template syntax in the URL parameter and call the ParsePathParams method to fill in the data. To continue the above example, say we're accessing multiple user's reports. We might have data in the following form: type UserReport struct { UserID string ReportID string } We can create our Request object like so: baseReq := requests . Request { URL : `/api/users/{{ .UserID }}/reports/{{ .ReportID }}` } fmt . Println ( baseReq . URL ) // Output: /api/users/{{ .UserID }}/reports/{{ .ReportID }} And we can create new request objects from our baseReq using instances of UserReport . data := [] UserReport { { \"u123\" , \"r456\" }, { \"u321\" , \"r654\" }, { \"u111\" , \"r222\" }, } for _ , ur := range data { req , err := baseReq . ParsePathParams ( & ur ) if err != nil { panic ( err ) } fmt . Println ( req . URL ) } You'll get the following output: /api/users/u123/reports/r456 /api/users/u321/reports/r654 Go templates are a really powerful feature of the language and you can read more about them here .","title":"How can requests help?"},{"location":"requests/path-params/#safely-encoding-path-parameters","text":"There is a limited set of characters that are considered safe for URLs (See section 2.3 of RFC 3986 ), and they are: ALPHA DIGIT \"-\" / \".\" / \"_\" / \"~\" requests includes a helper function, URLEncode , to allow you to escape unsafe characters when parsing Path parameters. func URLEncode ( data interface {}) string URLEncode is a convenience function that applies fmt.Sprint and then url.PathEscape . In addition to being a package function, URLEscape is also available in the URL Go template. For example, say we have the following URL template: /api/{{ .Message }} and we want to pass in the message \"Hello, World!\". We'll run into a bit of an issue, since the comma, the space, and the exclamation point are all considered unsafe characters. We can update our template as follows: /api/{{ .Message | URLEscape }} and by piping .Message into the URLEscape function, we'll end up with the following: /api/Hello%2C%20World%21 Yay! Back to safety! If you know your parameters are safe, you can skip URLEscape , but it's there if you need it.","title":"Safely Encoding Path Parameters"},{"location":"requests/path-params/#handling-errors","text":"Keep in mind that the ParsePathParams method returns both a new request and an error. If you're confident this call won't return an error, you can use the MustParsePathParams method, which only returns the new request and panics if an error is encountered.","title":"Handling Errors"}]}